<!doctype html>

<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>メジェドあきょのキャンディキャッチ</title>
  <style>
    :root{--bg:#0b1020;--panel:#0f1724;--accent:#ffd166;--muted:#94a3b8}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg) 0%, #071428 100%);font-family: Inter, system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Noto Sans JP", sans-serif;color:#e6eef8}
    .wrap{max-width:900px;margin:28px auto;padding:18px;background:rgba(255,255,255,0.03);border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{font-size:20px;margin:0}
    p.lead{margin:6px 0 0;color:var(--muted);font-size:13px}
    .game-area{display:flex;gap:16px;margin-top:12px}
    canvas{background:linear-gradient(180deg,#07203a,#041428);border-radius:8px;display:block;width:100%;height:auto}
    .sidebar{width:260px;min-width:220px}
    .panel{background:var(--panel);padding:12px;border-radius:10px}
    .row{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:linear-gradient(180deg,#1f2937,#111827);border:1px solid rgba(255,255,255,0.04);color:#fff;padding:8px 10px;border-radius:8px;font-size:13px;cursor:pointer}
    .small{font-size:13px;padding:6px 8px}
    .muted{color:var(--muted);font-size:13px}
    footer{margin-top:12px;color:var(--muted);font-size:12px}
    .hint{margin-top:8px;font-size:13px;color:var(--muted)}
    @media(max-width:820px){.game-area{flex-direction:column}.sidebar{width:100%}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>メジェドあきょのキャンディキャッチ</h1>
        <p class="lead">壺を持ったメジェドあきょが上から落ちてくるお菓子を拾って点数を稼ぐミニゲーム。キーボード／タッチで操作できます。</p>
      </div>
      <div>
        <div class="muted">作成: ChatGPT</div>
      </div>
    </header><div class="game-area">
  <div style="flex:1">
    <canvas id="gameCanvas" width="720" height="540"></canvas>
  </div>

  <div class="sidebar">
    <div class="panel">
      <div class="row"><div>Score</div><div id="score">0</div></div>
      <div class="row"><div>Lives</div><div id="lives">3</div></div>
      <div class="row"><div>Level</div><div id="level">1</div></div>
      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:10px 0">
      <div class="muted">Controls</div>
      <div class="hint">Keyboard: ← → to move, Space to pause<br>Touch: tap/drag on left or right side</div>
      <div style="height:10px"></div>
      <div class="controls">
        <button id="btnStart">Start</button>
        <button id="btnPause" class="small">Pause</button>
        <button id="btnReset" class="small">Reset</button>
      </div>
      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.03);margin:10px 0">
      <div class="muted">Settings</div>
      <div style="display:flex;gap:8px;margin-top:8px;flex-direction:column">
        <label class="muted">Spawn rate <input id="spawnRange" type="range" min="400" max="1600" step="50" value="900"></label>
        <label class="muted">Fall speed <input id="speedRange" type="range" min="60" max="260" step="10" value="120"></label>
      </div>
    </div>
  </div>
</div>

<footer>
  <div> </div>
</footer>

  </div><script>
// ---- Game constants & helpers ----
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// UI elements
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const levelEl = document.getElementById('level');
const btnStart = document.getElementById('btnStart');
const btnPause = document.getElementById('btnPause');
const btnReset = document.getElementById('btnReset');
const spawnRange = document.getElementById('spawnRange');
const speedRange = document.getElementById('speedRange');

// game state
let score = 0, lives = 3, level = 1;
let candies = [];
let lastSpawn = 0;
let spawnInterval = Number(spawnRange.value); // ms between spawns (lower => more frequent)
let baseFallSpeed = Number(speedRange.value); // pixels per second-ish
let running = false, paused = false;
let lastTime = performance.now();

// player (メジェド神 with a jar)
const player = {
  x: W/2,
  y: H - 90,
  w: 140,
  h: 100,
  speed: 520, // px/sec
  targetX: null
};

// handle resize for pixel-perfect drawing (keeps logical size constant)
function resizeCanvas(){
  // canvas.style.width = '100%'; // leave CSS responsive
  W = canvas.width = 720;
  H = canvas.height = 540;
  player.y = H - 90;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Candy types
const candyTypes = [
  {name:'choco',score:10, radius:18},
  {name:'macaron',score:20, radius:20},
  {name:'lollipop',score:15, radius:16},
  {name:'heart',score:30, radius:22}
];

function rand(min,max){return Math.random()*(max-min)+min}

// spawn candy
function spawnCandy(){
  const t = candyTypes[Math.floor(Math.random()*candyTypes.length)];
  const x = rand(30, W-30);
  const fallSpeed = baseFallSpeed * rand(0.8, 1.4); // px/sec
  candies.push({x, y:-30, r:t.radius, type:t, vy: fallSpeed, wob: rand(0,Math.PI*2) });
}

// draw Medjed (stylized) holding a jar
function drawMedjed( file_000000002f0472078725754a90e8b57a.png ){
  // body (cloak)
  ctx.save();
  ctx.translate(x,y);
  // shadow under
  ctx.beginPath();
  ctx.ellipse(0,h*0.35,w*0.45,12,0,0,Math.PI*2);
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fill();

  // cloak
  ctx.beginPath();
  ctx.moveTo(-w*0.45, -h*0.25);
  ctx.quadraticCurveTo(-w*0.6, h*0.4, -w*0.05, h*0.6);
  ctx.quadraticCurveTo(w*0.2, h*0.68, w*0.45, h*0.35);
  ctx.quadraticCurveTo(w*0.13, -h*0.35, -w*0.45, -h*0.25);
  ctx.closePath();
  ctx.fillStyle = '#ffffff';
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  ctx.stroke();

  // single eye / mask
  ctx.beginPath();
  ctx.ellipse(0, -h*0.08, w*0.12, h*0.12, 0, 0, Math.PI*2);
  ctx.fillStyle = '#0b1320';
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(0, -h*0.08, w*0.06, h*0.06, 0, 0, Math.PI*2);
  ctx.fillStyle = '#a6d2ff';
  ctx.fill();

  // jar (held in front)
  const jarW = w*0.36, jarH = h*0.36;
  ctx.beginPath();
  ctx.ellipse(-w*0.12, h*0.02, jarW*0.68, jarH*0.6, 0, 0, Math.PI*2);
  ctx.fillStyle = '#f8f0e3';
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#d6c0a8';
  ctx.stroke();
  // jar rim
  ctx.beginPath();
  ctx.ellipse(-w*0.12, h*0.02 - jarH*0.46, jarW*0.48, jarH*0.22, 0, 0, Math.PI*2);
  ctx.fillStyle = '#d6c0a8';
  ctx.fill();

  ctx.restore();
}

// draw candy
function drawCandy(c){
  ctx.save();
  ctx.translate(c.x, c.y);
  // slight wobble
  const wob = Math.sin(c.wob + c.y*0.02) * 6;
  ctx.rotate(wob * Math.PI/180);

  // base circle
  ctx.beginPath();
  ctx.arc(0,0,c.r,0,Math.PI*2);
  // color by type
  const t = c.type.name;
  if(t==='choco') ctx.fillStyle = '#6b3f1a';
  else if(t==='macaron') ctx.fillStyle = '#ff87c1';
  else if(t==='lollipop') ctx.fillStyle = '#ffd166';
  else ctx.fillStyle = '#7be495';
  ctx.fill();

  // shine
  ctx.beginPath();
  ctx.ellipse(-c.r*0.3, -c.r*0.3, c.r*0.35, c.r*0.2, 0, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.18)';
  ctx.fill();

  // stick for lollipop
  if(t==='lollipop'){
    ctx.beginPath();
    ctx.moveTo(c.r*0.4, c.r*0.5);
    ctx.lineTo(c.r*0.4, c.r*1.6);
    ctx.lineWidth = 6;
    ctx.strokeStyle = '#e7dcc6';
    ctx.stroke();
  }

  ctx.restore();
}

// update loop
function update(dt){
  if(paused || !running) return;
  // spawn logic
  lastSpawn += dt * 1000;
  spawnInterval = Number(spawnRange.value);
  baseFallSpeed = Number(speedRange.value);
  if(lastSpawn > spawnInterval){
    spawnCandy();
    lastSpawn = 0;
  }

  // update candies
  for(let i=candies.length-1;i>=0;i--){
    const c = candies[i];
    c.y += (c.vy * dt);
    c.wob += dt*3;

    // remove when off screen
    if(c.y - c.r > H){
      candies.splice(i,1);
      lives -= 1;
      updateUI();
      if(lives <= 0) endGame();
      continue;
    }

    // collision with player jar area (approximate)
    const jarX = player.x - player.w*0.12;
    const jarY = player.y - player.h*0.1;
    const jarW = player.w*0.36;
    const jarH = player.h*0.36;
    // simple AABB <-> circle test
    const dx = Math.max(jarX - c.x, 0, c.x - (jarX + jarW));
    const dy = Math.max(jarY - c.y, 0, c.y - (jarY + jarH));
    if(dx*dx + dy*dy <= c.r*c.r){
      // caught
      score += c.type.score;
      candies.splice(i,1);
      updateUI();
      // level up every 200 points
      const newLevel = Math.floor(score / 200) + 1;
      if(newLevel !== level){ level = newLevel; levelEl.textContent = level; }
    }
  }

  // player movement (towards targetX or keyboard controlled set)
  if(player.targetX !== null){
    const dir = player.targetX - player.x;
    const maxMove = player.speed * dt;
    if(Math.abs(dir) <= maxMove) player.x = player.targetX;
    else player.x += Math.sign(dir) * maxMove;
  }

  // clamp
  player.x = Math.max(player.w*0.5, Math.min(W - player.w*0.5, player.x));
}

function draw(){
  // background
  ctx.clearRect(0,0,W,H);

  // simple star-like particles
  for(let i=0;i<40;i++){
    const sx = (i*53) % W;
    const sy = (i*79 + (performance.now()*0.002*i)) % H;
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(sx, sy, 2,2);
  }

  // candies
  for(const c of candies) drawCandy(c);

  // player
  drawMedjed(player.x, player.y, player.w, player.h);

  // HUD overlay on canvas (optional small)
  ctx.fillStyle = 'rgba(0,0,0,0.25)';
  ctx.fillRect(10,10,160,56);
  ctx.fillStyle = '#fff';
  ctx.font = '16px sans-serif';
  ctx.fillText('Score: ' + score, 18, 32);
  ctx.fillText('Lives: ' + lives, 18, 52);
}

function gameLoop(t){
  const dt = Math.min(0.05, (t - lastTime) / 1000);
  lastTime = t;
  update(dt);
  draw();
  if(running) requestAnimationFrame(gameLoop);
}

// ---- Controls ----
let keys = {};
window.addEventListener('keydown', e=>{
  if(e.key === 'ArrowLeft'){ player.targetX = Math.max(player.w*0.5, player.x - 100); }
  if(e.key === 'ArrowRight'){ player.targetX = Math.min(W - player.w*0.5, player.x + 100); }
  if(e.code === 'Space') togglePause();
});

// touch controls: tap/drag left or right
let touching = false;
canvas.addEventListener('touchstart', e=>{
  touching = true;
  const tx = e.touches[0].clientX - canvas.getBoundingClientRect().left;
  if(tx < canvas.width/2) player.targetX = Math.max(player.w*0.5, player.x - 160);
  else player.targetX = Math.min(W - player.w*0.5, player.x + 160);
});
canvas.addEventListener('touchmove', e=>{
  const tx = e.touches[0].clientX - canvas.getBoundingClientRect().left;
  player.targetX = tx;
  e.preventDefault();
}, {passive:false});
canvas.addEventListener('touchend', e=>{ touching = false; player.targetX = null; });

// mouse click for desktop quick move
canvas.addEventListener('mousedown', e=>{
  const mx = e.clientX - canvas.getBoundingClientRect().left;
  player.targetX = mx;
});
canvas.addEventListener('mouseup', e=>{ player.targetX = null; });

// buttons
btnStart.addEventListener('click', ()=>{ startGame(); });
btnPause.addEventListener('click', ()=>{ togglePause(); });
btnReset.addEventListener('click', ()=>{ resetGame(); });

function updateUI(){ scoreEl.textContent = score; livesEl.textContent = lives; }

function startGame(){
  if(running) return;
  running = true; paused = false;
  score = 0; lives = 3; level = 1; candies = []; lastSpawn = 0; updateUI(); levelEl.textContent = level;
  lastTime = performance.now();
  requestAnimationFrame(gameLoop);
}

function togglePause(){
  if(!running) return;
  paused = !paused;
  btnPause.textContent = paused ? 'Resume' : 'Pause';
  if(!paused){ lastTime = performance.now(); }
}

function endGame(){
  running = false;
  paused = false;
  alert('ゲームオーバー！\nScore: ' + score);
}

function resetGame(){
  running = false; paused = false; candies = []; score = 0; lives = 3; level = 1; updateUI(); levelEl.textContent = level; btnPause.textContent = 'Pause'; draw();
}

// initial draw
resetGame();

</script></body>
</html>
